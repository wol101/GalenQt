# GalenQt recipe file generated by generate_default_recipes.py

<TITLE>
Isomap
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_Isomap(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_Isomap.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
Isomap_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_Isomap()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('Isomap_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'Isomap';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'Isomap';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Landmark Isomap
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LandmarkIsomap(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LandmarkIsomap.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LandmarkIsomap_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LandmarkIsomap()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LandmarkIsomap_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LandmarkIsomap';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LandmarkIsomap';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Laplacian Eigenmaps
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_Laplacian(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_Laplacian.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
Laplacian_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_Laplacian()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('Laplacian_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'Laplacian';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'Laplacian';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Hession Local Linear Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_HLLE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_HLLE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
HLLE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_HLLE()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('HLLE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'HLLE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'HLLE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Local Linear Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LLE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LLE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LLE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LLE()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LLE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LLE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LLE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Gaussian Process Latent Variable Model
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_GPLVM(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_GPLVM.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
GPLVM_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_GPLVM()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('GPLVM_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'GPLVM';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'GPLVM';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Local Linear Coordination
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LLC(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LLC.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LLC_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LLC()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LLC_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LLC';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LLC';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Manifold Charting
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_ManifoldChart(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_ManifoldChart.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
ManifoldChart_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_ManifoldChart()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('ManifoldChart_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'ManifoldChart';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'ManifoldChart';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Coordinated Factor Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_CFA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_CFA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
CFA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_CFA()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('CFA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'CFA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'CFA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Local Tangent Space Alignment
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LTSA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LTSA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LTSA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LTSA()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LTSA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LTSA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LTSA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Linear Local Tangent Space Alignment
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LLTSA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LLTSA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LLTSA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LLTSA()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LLTSA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LLTSA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LLTSA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Landmark Maximum Variance Unfolding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LMVU(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LMVU.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LMVU_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LMVU()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LMVU_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LMVU';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LMVU';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Fast Maximum Variance Unfolding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_FastMVU(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_FastMVU.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
FastMVU_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_FastMVU()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('FastMVU_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'FastMVU';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'FastMVU';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Conformal Eigenmaps (aka MVU)
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_Conformal(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_Conformal.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
Conformal_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_Conformal()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('Conformal_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'Conformal';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'Conformal';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Diffusion Maps
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_DM(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_DM.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
DM_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_DM()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('DM_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'DM';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'DM';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Stochastic Proximity Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_SPE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_SPE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
SPE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_SPE()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('SPE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'SPE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'SPE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Locality Preserving Projection
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LPP(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LPP.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LPP_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LPP()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LPP_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LPP';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LPP';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Neighborhood Preserving Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_NPE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_NPE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
NPE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_NPE()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('NPE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'NPE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'NPE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Stochastic Neighbor Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_SNE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_SNE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
SNE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_SNE()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('SNE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'SNE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'SNE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Symmetric Stochastic Neighbor Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_SymSNE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_SymSNE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
SymSNE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_SymSNE()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('SymSNE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'SymSNE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'SymSNE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
t-Distributed Stochastic Neighbor Embedding
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_tSNE(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_tSNE.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
tSNE_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_tSNE()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('tSNE_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'tSNE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'tSNE';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Deep Autoencoders Using Denoising Autoencoder Pretraining
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_AutoEncoder(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_AutoEncoder.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
AutoEncoder_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_AutoEncoder()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('AutoEncoder_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'AutoEncoder';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'AutoEncoder';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Kernel PCA
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_KPCA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_KPCA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
KPCA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_KPCA()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 1;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('KPCA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'KPCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'KPCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Generalized Discriminant Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_KLDA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_KLDA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
KLDA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_KLDA()

supervised_flag = 1;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('KLDA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'KLDA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'KLDA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Linear Discriminant Analysis (aka CVA)
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LDA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LDA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LDA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LDA()

supervised_flag = 1;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LDA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LDA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LDA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Maximally Collapsing Metric Learning
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_MCML(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_MCML.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
MCML_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_MCML()

supervised_flag = 1;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('MCML_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'MCML';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'MCML';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Neighborhood Components Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_NCA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_NCA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
NCA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_NCA()

supervised_flag = 1;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('NCA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'NCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'NCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Classical Multi-Dimensional Scaling
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_MDS(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_MDS.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
MDS_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_MDS()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('MDS_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'MDS';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'MDS';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Sammon Mapping
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_Sammon(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_Sammon.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
Sammon_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_Sammon()

supervised_flag = 0;
linear_flag = 0;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('Sammon_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'Sammon';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'Sammon';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Principal Component Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_PCA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_PCA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
PCA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_PCA()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('PCA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'PCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'PCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Simple Principal Component Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_SPCA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_SPCA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
SPCA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_SPCA()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('SPCA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'SPCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'SPCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Probabilistic Principal Component Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_PPCA(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_PPCA.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
PPCA_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_PPCA()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('PPCA_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'PPCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'PPCA';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Factor Analysis
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_FactorAnalysis(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_FactorAnalysis.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
FactorAnalysis_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_FactorAnalysis()

supervised_flag = 0;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('FactorAnalysis_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'FactorAnalysis';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'FactorAnalysis';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
<TITLE>
Large-Margin Nearest Neighbor
</TITLE>
<COMMAND_LINE>
matlab  -nodesktop -nojvm -r "try, galenqt_LMNN(), catch ME, disp(getReport(ME)), quit force, end, quit force"
</COMMAND_LINE>
<PROGRAM_NAME>
galenqt_LMNN.m
</PROGRAM_NAME>
<OUTPUT_IMAGE_REGEXP>
LMNN_channel_\d\d\d\.tif
</OUTPUT_IMAGE_REGEXP>
<SUBSAMPLES>
1000
</SUBSAMPLES>
<PROGRAM_TEXT>
function galenqt_LMNN()

supervised_flag = 1;
linear_flag = 1;
out_of_sample_flag = 0;
subsamples = SUBSAMPLES_MATLAB;
output_dimensions = OUTPUT_DIMENSIONS_MATLAB;

input_images = {INPUT_IMAGES_MATLAB};
output_images = cell(1, length(input_images));
for i = 1: length(input_images)
    output_images{i} = sprintf('LMNN_channel_%03d.tif', i);
end

addpath(genpath('/Users/wis/Synchronised/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));
addpath(genpath('/Users/wis/Research/Galen Manuscript//Downloads/Matlab Toolbox for Dimensionality Reduction/drtoolbox'));

model_image = input_images{1};
info = imfinfo(model_image);
width = info.Width;
height = info.Height;
bits = info.BitDepth;
colortype = info.ColorType;
fprintf('Model image "%s"\nWidth = %d Height = %d Bits per pixel = %d Type = "%s"\n', model_image, width, height, bits, colortype);

image_data_size = width * height;
n_images = length(input_images);
data_matrix = zeros(image_data_size, n_images);
tic;
for i_image = 1: n_images
    file_path = input_images{i_image};
    fprintf('Reading %s\n', file_path);
    raw_data = imread(file_path);
    data_matrix(:, i_image) = raw_data(:);
end
elapsed_time = toc;
fprintf('%d images read in %f seconds\n', n_images, elapsed_time);

if subsamples == 0
    A = data_matrix;
    type = 'LMNN';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedA, mapping] = compute_mapping(A, type, no_dims);
else
    sampled_row_indices = randperm(image_data_size, subsamples);
    X = data_matrix(sampled_row_indices, :);
    type = 'LMNN';
    no_dims = min([n_images, length(output_images), output_dimensions]);
    [mappedX, mapping] = compute_mapping(X, type, no_dims);
    
    if linear_flag || out_of_sample_flag
        mappedA = out_of_sample(data_matrix, mapping);
    else
        mappedA = out_of_sample_est(data_matrix, X, mappedX);
    end
end

[rows, cols] = size(mappedA);
for icol = 1: cols
    image_data = reshape(mappedA(:, icol), [height, width]);
    percentile_values = Percentile(image_data, [1, 99]);
    out_image = uint8(range_map(image_data, percentile_values(1), percentile_values(2), 0, 255, 0, 255));
    imwrite(out_image, output_images{icol}, 'compression', 'none');
end

% write blank images if there are too many
if (cols < length(output_images))
    out_image = zeros(height, width, 'uint8');
    for icol = cols + 1: length(output_images)
        imwrite(out_image, output_images{icol}, 'compression', 'lzw');
    end
end

return

% this function maps the dynamic range of an image from one range to another
function out_image = range_map(in_image, in_low, in_high, out_low, out_high, out_range_low, out_range_high)

in_range = in_high - in_low;
out_range = out_high - out_low;

out_image = ((double(in_image) - in_low) ./ in_range) .* out_range + out_low;

[out_range_low_r,out_range_low_c] = ind2sub(size(out_image),find(out_image < out_low));
[out_range_high_r,out_range_high_c] = ind2sub(size(out_image),find(out_image > out_high));

for i = 1: length(out_range_low_r)
    out_image(out_range_low_r(i), out_range_low_c(i)) = out_range_low;
end
for i = 1: length(out_range_high_r)
    out_image(out_range_high_r(i), out_range_high_c(i)) = out_range_high;
end

return

% calculate the percentiles of a list of values
function percentile_values = Percentile(arr, percentiles)

vals = sort(arr(:));
percentile_values = percentiles;
for i = 1: length(percentiles)
    index = round(1 + (percentiles(i)/100) * (length(vals) - 1));
    percentile_values(i) = vals(index);
end

return
</PROGRAM_TEXT>
